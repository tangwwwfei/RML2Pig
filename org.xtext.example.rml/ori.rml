grammar org.xtext.example.rml.IRML with org.eclipse.xtext.common.Terminals

generate iRML "http://www.xtext.org/example/rml/IRML"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Mapping:
	((namespaces+=Namespace | namedStructs+=NamedStruct | metadatas+=DocMetadata) '.')*
;

/*
 * Standard RML rules
 */
Namespace:
	('@prefix' prefix=(':' | PREFIX) iri=ANGLE_BRACKET) |
	('@base' iri=ANGLE_BRACKET)
;

DocMetadata:
	'[]' ((NSName|'dcterms:title'|'dcterms:description') PROPERTY)+
;

NamedStruct:
	name=Resource
	(crefTermMap=CrossRefTermMap |
	tripleMap=TripleMap |
	//tripleMap=ATripleMap |
	ls=ALogicalSource |
	sm=ASubjectMap|
	pom=APredicateObjectMap|
	om=AObjectMap|
	pm=APredicateMap|
	rom=AReferencingObjectMap|
	fnml=AFunctionTermMap|
	drdesc=DataRetrievalDescription)
;

CrossRefTermMap:
	logicalSourceDescription=LogicalSourceDescription | 
	predicateObjectMapDescription=RefCommonDescription |
	joinConditionDescription=JoinConditionDescription
;

DataRetrievalDescription:
	WebAPIsDescription | CSVOnWebDescription | DatasetDescription | SPARQLDescription | HydraDescriptioin | GRELFunctionDescription
	| GRELParameterDescription | GRELOutputDescription | D2RQDatabaseDescription
	
	| SimpleDatasetDescription 
	//| ConditionDescription
;

/*
 * 'a' 'rr:TriplesMap' ';'
	('rdfs:label' label=PROPERTY)?
	(tripleMap=TripleMap &
	dctype=DCTermtype?)
 */

TripleMap:
	('a' ('rr:TriplesMap'|'rml:TriplesMap') ';')? &
	('rdfs:label' label=PROPERTY)? &
	=>dctype=DCTermtype? &
	logicalSource=LogicalSource &	//rml:logicalSource
	subjectMap=SubjectMap &			//rr:subjectMap
	predicateObjectMaps += PredicateObjectMap*	//rr:predicateObjectMap
;

SourceDescription:
	('rml:source'|'rml:name' | 'rml:sourceName') 
		((source=PROPERTY) |
		(
			'['
				desc=DataRetrievalDescription
			(']' | '];' | ']' ';')
		))
;

LogicalSourceDescription:
	( 
		source=SourceDescription &
		('rml:iterator' iterator=PROPERTY)? &
		(('rml:referenceFormulation'|'rml:queryLanguage')referenceFormulation=PROPERTY)? &
		(('rml:query'|'rr:query') query=PROPERTY)? &
		('rr:sqlVersion' version=PROPERTY)? &
    	('rr:tableName' tableName=PROPERTY)?
	)
;

LogicalSource:
	{LogicalSource}
	'rml:logicalSource'
	(ref=PROPERTY |
	 ('['
	    desc=LogicalSourceDescription
	End))
;

rmlConditon:
	'rml:condition' '['
		(('rml:reference' reference=PROPERTY)? &
		('rml:condition' condition=MultiProperty))
	 End
;

rmlProcessCondition:
	'rml:processCondition' '['
		(('rml:condition' condition=MultiProperty) &
		('rml:reference' reference=PROPERTY)?)
	End
;

SubjectMapDescription:
	{SubjectMapDescription} (
			(valuedTermMap=ValuedTermMap|fnml=fnmlFunction)? &
			(datatype=DataType)? &
			(languageMap=LanguageMap)? &
			(type = TermType)? &
			classes+=CLASS* &
			graphMaps+=GraphMap* &
			condition=rmlConditon?
			//TODO functionTermMap
		)
;

SubjectMap:
	{SubjectMap} 
	'rr:subjectMap' 
	((ref=PROPERTY) |
	('['
		(
			desc=SubjectMapDescription
			('crml:equalCondition' equalName=PROPERTY)?
		)
	End))
;

InterPredicateObjectMap:
	'['
		((fnml=fnmlFunction|(predicateMaps+=PredicateMap+ &
    		objectMaps+=ObjectMap+)) &
		(graphMaps+=GraphMap*)
		& (dctype=DCTermtype)?
		& ('crml:equalCondition' equalName=PROPERTY)?
		& ('crml:fallbackMap' fallbackMap=PROPERTY)?)
	End
;

PredicateObjectMap:
	'rr:predicateObjectMap' 
	(refs+=PROPERTY (','refs+=PROPERTY)* |
	(preobjMaps += InterPredicateObjectMap+))
;

PredicateObjectMapDescription:
	dctype=DCTermtype? &
	(predicateMaps+=PredicateMap+ &
    		objectMaps+=ObjectMap+) &
    	graphMaps+=GraphMap*
		& (('crml:equalCondition' equalName=PROPERTY)?
		& ('crml:fallbackMap' fallbackMap=PROPERTY)?)
;

crmlEqualCondition:
	('crml:equalCondition' equalName=PROPERTY)?
	& ('crml:fallbackMap' fallbackMap=PROPERTY)?
	& ('crml:booleanCondition' bool=PROPERTY)?
;

fnmlFunction:
	'fnml:functionValue' '['
		(logicalSource=LogicalSource? &
	  	predicateObjectMap+=PredicateObjectMap+)
	End
;

ParentTermMap:
	'rml:parentTermMap' '['
		valuedTermMap=ValuedTermMap
	End
;

ObjectMapDescription:
	
	((parentTermMap=ParentTermMap|valuedTermMap=ValuedTermMap|fnml=fnmlFunction) & 
	datatype=DataType? &
	languageMap=LanguageMap? &
	type=TermType?&
	processCondition=rmlProcessCondition?) 
	(
	graphMaps+=GraphMap*
	& ('crml:equalCondition' equalName=PROPERTY)?
	& ('crml:fallbackMap' fallbackMap=PROPERTY)?
	& ('crml:booleanCondition' bool=PROPERTY)?)
	
;

ObjectMap:
	('rr:object'objects+=PROPERTY (',' objects+=PROPERTY)*) |
	('rr:objectMap' 
		((ref=PROPERTY) |
		('['
			(desc=ObjectMapDescription |
			refom=(ReferencingObjectMap|AReferencingObjectMap))
		End))
	)
;

ReferencingObjectMapDescription:
	'rr:parentTriplesMap' parentTriple=Resource (';')?
	(
		('[' joinConditions += JoinCondition+ End) |
		(joinConditions+=JoinCondition+)
	)?
;

ReferencingObjectMap:
	desc=ReferencingObjectMapDescription
	graphMaps+=GraphMap* &
	(conditon=ConditionDescription)?
;

JoinConditionDescription:
	('rr:child' child=PROPERTY) &
     	('rr:parent' parent=PROPERTY)
;

JoinCondition:
	('rr:joinCondition'|'rml:joinCondition')
	((ref=PROPERTY) |
	('['
	 	(desc=JoinConditionDescription | fnml=fnmlFunction)
     End))
;

PredicateMapDescription:
			(valuedTermMap=ValuedTermMap|fnml=fnmlFunction) & 
			(datatype=DataType)? &
			(languageMap=LanguageMap)? &
			(type=TermType)?
			& graphMaps+=GraphMap*
			& ('crml:equalCondition' equalName=PROPERTY)?
;

PredicateMap:
	(('rr:predicate') predicates+=PROPERTY (',' predicates+=PROPERTY)*) |
	('rr:predicateMap' 
	(ref=PROPERTY |
	('['
		(
			pm=PredicateMapDescription
		)
	End)))
;

GraphMap:
	('rr:graph' graphs+=PROPERTY (',' graphs+=PROPERTY)*) |
		(('rr:graphMap'|'rr:graph') '['((fnml=fnmlFunction|valuedTermMap=ValuedTermMap) & termType=TermType?) End)
;

LanguageMap:
	('rr:language' langs+=PROPERTY (',' langs+=PROPERTY)*) |
		('rml:languageMap' '['valuedTermMap=ValuedTermMap End)
;

/*
 * Standard RML rules END
 */


/*
 * Reference RML rules
 */
 
 RefCommonDescription:
	dctype=DCTermtype? &
	valuedTermMap=ValuedTermMap? &
	refObjectMaps+=ReferencingObjectMapDescription* &
	(predicateMaps+=PredicateMap* &
	objectMaps+=ObjectMap*) &
	graphMaps+=GraphMap* & 
	equalCondition=crmlEqualCondition? &
	classes+=CLASS* &
	(conditon=ConditionDescription)?
 ;
 
/*
 * RMl rules - start with 'a'
 */

ALogicalSource returns LogicalSourceDescription:
	'a' 'rml:LogicalSource' ';'
	lsdesc=LogicalSourceDescription
;

ASubjectMap returns SubjectMapDescription:
	'a' 'rr:SubjectMap' ';'
	SubjectMapDescription
;

APredicateObjectMap returns PredicateObjectMapDescription:
	'a' 'rr:PredicateObjectMap' ';'
	PredicateObjectMapDescription
;

AObjectMap returns ObjectMapDescription:
	'a''rr:ObjectMap' ';'
	(ObjectMapDescription | ReferencingObjectMapDescription)
;

AFunctionTermMap:
	'a' 'fnml:FunctionTermMap' ';'
	'fnml:functionValue' functionValue=PROPERTY
	('rr:datatype' datatype=DataType)?
	(class=CLASS)?
;

APredicateMap returns PredicateMapDescription:
	'a' 'rr:PredicateMap' ';'
	PredicateMapDescription
;

AReferencingObjectMap returns ReferencingObjectMap:
	'a' 'rr:RefObjectMap' ';'
	ReferencingObjectMap
;

ATripleMap returns TripleMap:
	'a' 'rr:TriplesMap' ';'
	('rdfs:label' label=PROPERTY)?
	(tripleMap=TripleMap &
	dctype=DCTermtype?)
;

/*
 * RMl rules - start with 'a' END
 */

//rr:subject, rr:predicate, rr:object and rr:graph
Constant returns TermMap:
	'rr:constant' value=PROPERTY
;

Reference  returns TermMap:
	'rml:reference' value=PROPERTY
;

Template  returns TermMap:
	'rr:template' value=PROPERTY
;

TermTypeValue:
	('rr:BlankNode'|'rr:Literal' | 'rr:IRI') ';'?
;

TermType:
	'rr:termType' value=TermTypeValue
;

DataType:
	'rr:datatype' value=PROPERTY|value=TermTypeValue
;

ValuedTermMap:
	constant=Constant | reference=Reference | template=Template
;

CLASS:
	'rr:class' iris+=PROPERTY (',' iris+=PROPERTY)*
;

//
D2RQDatabaseDescription:
	'a' 'd2rq:Database' ';'
	'd2rq:jdbcDSN' dsn=PROPERTY// # the "jbdc:mysql:// part is ignored
	'd2rq:jdbcDriver' driver=PROPERTY//; # this is ignored
	'd2rq:username' username=PROPERTY
	'd2rq:password' password=PROPERTY
;
//GREL function
GRELFunctionDescription:
	'a' 'fno:Function' ';'
	'fno:name' name=PROPERTY
	'rdfs:label' label=PROPERTY
	'dcterms:description' desc=PROPERTY
	'fno:expects' '(' expects+=Resource* ')' ';'
	'fno:returns' '(' return=Resource ')' ';'
	'lib:providedBy' '['
		'lib:localLibrary' loclib=PROPERTY
		'lib:class' class=PROPERTY
		'lib:method' method=PROPERTY
  ']'
;

GRELParameterDescription:
	'a' 'fno:Parameter' ';'
	'fno:name' name=PROPERTY
	'rdfs:label' label=PROPERTY
	'fno:type' type=PROPERTY
	'fno:predicate' predicate=Resource
;

GRELOutputDescription:
	'a' 'fno:Output' ';'
	'fno:name' name=PROPERTY
	'rdfs:label' label=PROPERTY
	'fno:type' type=PROPERTY
	'fno:predicate' predicate=Resource
;

WebAPIsDescription:
	'a' 'hydra:IriTemplate' ';'
	'hydra:template' value=PROPERTY
	('hydra:mapping' '['
		('hydra:variable' variable=PROPERTY
    	'hydra:required' require=PROPERTY)
	']')?
;

HydraDescriptioin:
	'a' 'hydra:PagedCollection' ';'
	'hydra:itemsPerPage' itemsPerPage=PROPERTY
	'hydra:firstPage' firstPage=PROPERTY
	'hydra:nextPage' nextPage=PROPERTY
;

CSVOnWebDescription:
	'a' 'csvw:Table' ';'
    'csvw:url' url=PROPERTY
    'csvw:dialect' '[' 
    	('a' 'csvw:Dialect' ';'
        ('csvw:delimiter' delimiter=PROPERTY) &
        ('csvw:encoding' encoding=PROPERTY) &
        ('csvw:header' header=PROPERTY) &
        ('csvw:headerRowCount' headerRowCount=PROPERTY)? &
        ('csvw:trim' trim=PROPERTY)?)
	']'
;

SPARQLDescription:
	('a' 'sd:Service' ';'
    ('sd:endpoint' endpoint=PROPERTY) &
    ('sd:supportedLanguage' 'sd:SPARQL11Query' ';')? &
    ('sd:resultFormat' resultFormat=PROPERTY)? 
    )
;

DatasetDescription:
	'a' 'dcat:Dataset' ';'
    'dcat:distribution'
	('['
	    ('a' 'dcat:Distribution' ';'
	    'dcat:downloadURL' downloadURL=PROPERTY)
    ']') 
;

SimpleDatasetDescription:
	('a' 'dcat:Distribution' ';')
	('dcat:downloadURL' downloadURL=PROPERTY)
;

ConditionDescription:
	('crml:condition' conditon=PROPERTY)? //three quotes
    'crml:binding' '['
        (('crml:variable' variable=PROPERTY)&
        valuedTermMap=ValuedTermMap&
        termType=TermType?)
    ']'
;

DCTermtype:
	'dcterms:type' dctype=PROPERTY
;

PREFIX:
	'co:'| //Verification  Completion  requires
	'rr:'| //
	'rml:'|
	'rdfs:'|
	'rdf:'|
	'hydra:'|
	'prov:'|
	'd2rq:'|
	'ql:'|
	'r2rml:'|
	'sd:'|
	'csvw:'|
	'crml:'|
	'dcat:'|
	'fnml:'|
	'dcterms:' |
	'fno:'|
	'lib:'|
	//'grel:'|
	ID ':'
;

Resource:
	NSName | ANGLE_BRACKET
;

NSName returns ecore::EString:
	PREFIX ID
;

MultiProperty:
	values+=PROPERTY (',' values+=PROPERTY)*
;

PROPERTY returns ecore::EString:
	(Keywords | Boolean | DatatypeDesc | STRING | NSName | ANGLE_BRACKET) (';')?
;

Keywords:
	'dcterms:type' |
	'dcterms:title' |
	'rdfs:label' |
	'fno:executes' |
	'dcterms:description' |
	'dcterms:date' |
	'rr:SQL2008' |
	'rr:defaultGraph'
;

Boolean returns ecore::EString:
	'true' |
	'false'
;

DatatypeDesc returns ecore::EString:
	STRING '^^' ID (':' ID)*
;

End:
	(']' | '];' | ']'';' | '],' | ']'',')
;

/*terminal CO_PREFIX: 'co:';
terminal RR_PREFIX: 'rr:';
terminal RML_PREFIX: 'rml:';
terminal HYDRA_PREFIX: 'hydra:';
terminal PROV_PREFIX: 'prov:';
terminal D2RQ_PREFIX: 'd2rq:';
terminal QL_PREFIX: 'ql:';
terminal R2RML_PREFIX: 'r2rml:';
terminal SD_PREFIX: 'sd:';
terminal CSVW_PREFIX: 'csvw:';
terminal CRML_PREFIX: 'crml:';
terminal DCAT_PREFIX: 'dcat:';
terminal FNML_PREFIX: 'fnml:';
terminal DCTERMS_PREFIX: 'dcterms:';
terminal VOID_PREFIX: 'void:';*/

terminal ANGLE_BRACKET : '<' -> '>';
@Override 
terminal ID : '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'-'|'0'..'9')*;
@Override
terminal SL_COMMENT : '#' !('\n'|'\r')* ('\r'? '\n')?;
@Override
terminal STRING:
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
			"'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'" |
			'"""' -> '"""'
		;
